from math import floor, ceil
from queue import PriorityQueue

from numpy import mintypecode

# there is a theorem that says that for a supersingular Elliptic Curve E
# defined over Fq, q = p^2 such that the (p^r)-th power Frobenius endomorphism has
# trace +/- 2p^r, we have E(F(q^r)) ~ Z/(p^r -/+ 1)Z x Z/(p^r -/+ 1)Z.
# Thus E(F(q^r)) = E[p -/+ 1]
# E.g. DeFeo, Thm 54

# it follows that if the q-th power Frobenius endomorphism has trace +/- 2p,
# then E(F(q)) ~ Z/(p^r -/+ 1)Z x Z/(p^r -/+ 1)Z and for r > 1 have 
# E(F(q^r)) ~ Z/(p^r - 1)Z x Z/(p^r - 1)Z

# We call these curves nice

def is_nice(E):
    """Returns true if E is a supersingular Elliptic Curve defined over Fq, q = p^2
    such that the q-th power Frobenius endomorphism has trace +/- 2p"""
    if not E.is_supersingular():
        return False
    p = E.base_field().characteristic()
    if not E.base_field() == GF(p**2):
        return False
    n = E.cardinality()
    return n == (p + 1)**2 or n == (p - 1)**2

def frob_trace(E):
    """Computes the trace of the q-th power frobenius endomorphism for a nice Elliptic Curve E"""
    p = E.base_field().characteristic()
    return p**2 + 1 - E.cardinality()

def rational_point_count(E, r):
    """Computes the number #E(F(q^r)), assuming that E is a nice Elliptic Curve"""
    if r == 0:
        return 1
    tr = frob_trace(E)
    q = E.base_field().characteristic()**2
    alpha = tr/2 + sqrt(CC(tr**2/4 - q))
    beta = tr/2 - sqrt(CC(tr**2/4 - q))
    return Integer((q**r + 1 - alpha**r - beta**r).real())

def rational_point_gens(E, r):
    """Computes generators of the group E(F(q^r)) for a nice Elliptic Curve E"""
    q = E.base_field().characteristic()**2
    return E.base_extend(GF(q**r)).gens()

def torsion_group_gens(E, l, rational_gens = [0, None, None]):
    """Computes generators of the group E[l] for a nice Elliptic Curve E. This uses
    the generators of the group E(F(q^r)) for different r. In case some of this data
    is already available, you can pass `rational_gens = [r, P, Q]` where P and Q are
    F(q^r)-rational points that generate E(F(q^r)). If new [r, P, Q] are computed
    during the function call, these are again stored in `rational_gens`"""
    r, P, Q = rational_gens
    if rational_point_count(E, r) % l**2 != 0:
        r += 1
        while rational_point_count(E, r) % l**2 != 0:
            r += 1
        P, Q = rational_point_gens(E, r)
    rational_gens[0] = r
    rational_gens[1] = P
    rational_gens[2] = Q

    n = sqrt(rational_point_count(E, r))

    return (P * Integer(n / l), Q * Integer(n / l))

def two_dim_discrete_log(P, Q1, Q2, n):
    """Assumes that P is in the group generated by Q1 and Q2, and further
    that Q1, Q2 have order n. Computes a, b such that P = a Q1 + b Q2"""
    E = P.curve()
    assert P * n == E(0, 1, 0)
    assert Q1 * n == E(0, 1, 0)
    assert Q2 * n == E(0, 1, 0)
    steps = int(sqrt(n)) + 1
    R1 = Q1 * steps
    R2 = Q2 * steps
    giant_steps = { R1 * i + R2 * j: (i, j) for j in range(steps) for i in range(steps) }
    for k in range(steps):
        for l in range(steps):
            R = P + Q1 * k + Q2 * l
            if R in giant_steps:
                i, j = giant_steps[R]
                return (i * steps - k, j * steps - l)

def find_nontrivial_endo_cycle(E, l):
    """Finds a nontrivial cycle in the l-isogeny graph of E and returns a list
    of l-isogenies and isomorphisms of this circle"""
    F = E.base_field()
    assert l != F.characteristic()
    open = PriorityQueue()
    found = {}
    open.put((0, E))
    found[E.j_invariant()] = None
    while True:
        prio, curve = open.get()
        for f in curve.isogenies_prime_degree(l):
            target = f.codomain().j_invariant()
            if target in found:
                if f.dual() == found[curve.j_invariant()]:
                    continue

                f = f.domain().isogeny(f.kernel_polynomial(), degree = f.degree(), codomain = found[target].codomain())
                circle_len = 1
                result = [f.dual()]
                current = curve.j_invariant()
                while found[current] != None:
                    result.append(found[current].dual())
                    circle_len += 1
                    current = found[current].domain().j_invariant()
                result.reverse()
                current = target
                while found[current] != None:
                    result.append(found[current])
                    circle_len += 1
                    current = found[current].domain().j_invariant()
                return (result, l**circle_len)
            else:
                found[target] = f
                open.put((prio + 1, target))

def eval_endo_cycle(endo_cycle, P):
    F = P.curve().base_field()
    for f in reversed(endo_cycle):
        P = f.domain().base_extend(F).isogeny(f.kernel_polynomial(), degree = f.degree(), codomain = f.codomain().base_extend(F))(P)
    return P

def min_repr(a):
    n = a.parent().order()
    a = ZZ(a)
    if a > n/2:
        a -= n
    return a

def find_mipo_mod_n(E, _, endo, r):
    n = Integer(sqrt(rational_point_count(E, r)))
    Q1, Q2 = rational_point_gens(E, r)
    P1 = endo(Q1)
    P2 = endo(Q2)
    r1, s1 = two_dim_discrete_log(P1, Q1, Q2, n)
    assert P1 == r1 * Q1 + s1 * Q2
    r2, s2 = two_dim_discrete_log(P2, Q1, Q2, n)
    assert P2 == r2 * Q1 + s2 * Q2

    R = Integers(n)
    A = Matrix(R, [[r1, r2], [s1, s2]])
    print(A)
    f = A.charpoly()
    return (min_repr(f[1]), min_repr(f[0]))

def find_mipo(E, l, endo):
    endo_cycle, endo_deg = endo
    # using that deg is a positive definite quadratic form (and thus
    # satisfies a reverse triangle inequality), we find that for the
    # minimal polynomial T^2 + a T + b = 0 of the endomorphism, have
    # either that |a/b| == sqrt(endo_deg) or |a| + |b| <= endo_deg/epsilon,
    # where epsilon is the distance between sqrt(endo_deg) to the
    # closest integer (or 1, if sqrt(endo_deg) is an integer)
    epsilon = 1.
    if not is_square(endo_deg):
        endo_deg_sqrt = float(sqrt(endo_deg))
        epsilon = min(
            endo_deg_sqrt - floor(endo_deg_sqrt),
            ceil(endo_deg_sqrt) - endo_deg_sqrt
        )
    coeff_bound = endo_deg / epsilon


    print(coeff_bound)

F = GF(37**2)
E = EllipticCurve(F, j = 3 + sqrt(F(15)))
assert E.is_supersingular()

print(sqrt(rational_point_count(E, 2)))

print(find_mipo_mod_n(E, 3, lambda P: P + P, 2))

cycle, deg = find_nontrivial_endo_cycle(E, 3)
endo = lambda P: eval_endo_cycle(cycle, P)
print(find_mipo_mod_n(E, 3, endo, 2))
# mipo will be x^2 - 2x + 9
# so in End(E) have i^2 == -8

print(find_mipo_mod_n(E, 3, lambda P: endo(P) - P, 2))

cycle, deg = find_nontrivial_endo_cycle(E, 5)
endo = lambda P: eval_endo_cycle(cycle, P)
print(find_mipo_mod_n(E, 5, endo, 2))
# mipo will be x^2 + 2x + 25
# so in End(E) have j^2 == -26

print(find_mipo_mod_n(E, 5, lambda P: endo(P) + P, 2))

cycle, deg = find_nontrivial_endo_cycle(E, 7)
endo = lambda P: eval_endo_cycle(cycle, P)
print(find_mipo_mod_n(E, 7, endo, 2))